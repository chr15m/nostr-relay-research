<!DOCTYPE html>
<html>
<head>
    <title>Nostr DHT Lookup Simulator</title>
    <meta charset="utf-8" />
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: sans-serif; }
        #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 2em; color: #555; }
        svg { width: 100%; height: 100%; background-color: #fdfdfd; }
        .node-group { cursor: pointer; }
        .node-circle { fill: #333; }
        .node-label { font-family: monospace; font-size: 10px; fill: #888; text-anchor: middle; user-select: none; }
        .highlight { fill: none; stroke: red; stroke-width: 2px; transition: opacity 0.5s; }
        .result-highlight { fill: none; stroke: blue; stroke-width: 2px; }
        .path-line { stroke: #a66; stroke-width: 1px; opacity: 0.5; marker-end: url(#arrowhead-grey); }
        .path-line.best-path { stroke: red; stroke-width: 2px; opacity: 1; marker-end: url(#arrowhead-red); }
    </style>
</head>
<body>
    <div id="lookup-container" style="position: absolute; top: 10px; left: 50%; transform: translateX(-50%); z-index: 10; display: none; background: white; padding: 10px; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
        <input type="text" id="npub-input" placeholder="Paste npub or hex pubkey to find" size="40">
        <button id="lookup-button">Lookup</button>
    </div>
    <div id="loading">Initializing DHT...</div>
    <svg id="dht-svg" style="visibility: hidden;">
        <defs>
            <marker id="arrowhead-grey" markerWidth="5" markerHeight="3.5" refX="5" refY="1.75" orient="auto">
                <polygon points="0 0, 5 1.75, 0 3.5" fill="#cccccc" />
            </marker>
            <marker id="arrowhead-red" markerWidth="5" markerHeight="3.5" refX="5" refY="1.75" orient="auto">
                <polygon points="0 0, 5 1.75, 0 3.5" fill="red" />
            </marker>
        </defs>
    </svg>

    <script>
        (async () => {
            // --- Bech32 decoder ---
            // From https://github.com/bitcoinjs/bech32
            const bech32 = (() => {
                const ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
                const ALPHABET_MAP = {};
                for (let z = 0; z < ALPHABET.length; z++) {
                    const x = ALPHABET.charAt(z);
                    ALPHABET_MAP[x] = z;
                }
                function polymod(values) {
                    const GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
                    let chk = 1;
                    for (let p = 0; p < values.length; ++p) {
                        const top = chk >> 25;
                        chk = (chk & 0x1ffffff) << 5 ^ values[p];
                        for (let i = 0; i < 5; ++i) {
                            if ((top >> i) & 1) {
                                chk ^= GEN[i];
                            }
                        }
                    }
                    return chk;
                }
                function hrpExpand(hrp) {
                    const ret = [];
                    let p;
                    for (p = 0; p < hrp.length; ++p) {
                        ret.push(hrp.charCodeAt(p) >> 5);
                    }
                    ret.push(0);
                    for (p = 0; p < hrp.length; ++p) {
                        ret.push(hrp.charCodeAt(p) & 31);
                    }
                    return ret;
                }
                function verifyChecksum(hrp, data) {
                    return polymod(hrpExpand(hrp).concat(data)) === 1;
                }
                function decode(bechString) {
                    let p;
                    let hasLower = false;
                    let hasUpper = false;
                    for (p = 0; p < bechString.length; ++p) {
                        if (bechString.charCodeAt(p) < 33 || bechString.charCodeAt(p) > 126) {
                            return null;
                        }
                        if (bechString.charCodeAt(p) >= 97 && bechString.charCodeAt(p) <= 122) {
                            hasLower = true;
                        }
                        if (bechString.charCodeAt(p) >= 65 && bechString.charCodeAt(p) <= 90) {
                            hasUpper = true;
                        }
                    }
                    if (hasLower && hasUpper) {
                        return null;
                    }
                    bechString = bechString.toLowerCase();
                    const pos = bechString.lastIndexOf('1');
                    if (pos < 1 || pos + 7 > bechString.length || bechString.length > 90) {
                        return null;
                    }
                    const hrp = bechString.substring(0, pos);
                    if (hrp.length === 0) {
                        return null;
                    }
                    const data = [];
                    for (p = pos + 1; p < bechString.length; ++p) {
                        const d = ALPHABET_MAP[bechString.charAt(p)];
                        if (d === undefined) {
                            return null;
                        }
                        data.push(d);
                    }
                    if (!verifyChecksum(hrp, data)) {
                        return null;
                    }
                    return { prefix: hrp, words: data.slice(0, -6) };
                }
                function fromWords(words) {
                    let bits = 0;
                    let value = 0;
                    let output = [];
                    let maxV = (1 << 8) - 1;
                    for (let i = 0; i < words.length; i++) {
                        value = (value << 5) | words[i];
                        bits += 5;
                        while (bits >= 8) {
                            bits -= 8;
                            output.push((value >> bits) & maxV);
                        }
                    }
                    return output;
                }
                return { decode, fromWords };
            })();

            // --- DOM Elements ---
            const svg = document.getElementById('dht-svg');
            const loadingDiv = document.getElementById('loading');
            const lookupContainer = document.getElementById('lookup-container');
            const npubInput = document.getElementById('npub-input');
            const lookupButton = document.getElementById('lookup-button');
            const NS = "http://www.w3.org/2000/svg";

            // --- DHT Constants and Config ---
            const K = 8;
            const ALPHA = 3;
            const ID_LENGTH_BITS = 256;
            const MAX_DISTANCE = 2n ** BigInt(ID_LENGTH_BITS);
            const relayUrls = [
                "wss://a.nos.lol", "wss://adeptus.cwharton.com", "wss://ae.purplerelay.com", "wss://aegis.relayted.de",
                "wss://airchat.nostr1.com", "wss://antisocial.nostr1.com", "wss://aplaceinthesun.nostr1.com",
                "wss://articles.layer3.news", "wss://asia.azzamo.net", "wss://at.nostrworks.com", "wss://auth.nostr1.com",
                "wss://backup.keychat.io", "wss://basedpotato.nostr1.com", "wss://bevo.nostr1.com", "wss://bitcoiner.social",
                "wss://bitcoinmaximalists.online", "wss://bnc.netsec.vip", "wss://bostr.bitcointxoko.com",
                "wss://bostr.lightningspore.com", "wss://brainstorm.nostr1.com", "wss://btc.klendazu.com",
                "wss://bucket.coracle.social", "wss://budabit.nostr1.com", "wss://carlos-cdb.top", "wss://ch.purplerelay.com",
                "wss://chadf.nostr1.com", "wss://chorus.bonsai.com", "wss://chorus.tealeaf.dev", "wss://christpill.nostr1.com",
                "wss://chronicle.ziomc.com", "wss://custom.fiatjaf.com", "wss://cyberspace.nostr1.com", "wss://czas.top",
                "wss://david.nostr1.com", "wss://de.purplerelay.com", "wss://dev-relay.lnfi.network",
                "wss://dikaios1517.nostr1.com", "wss://dwebcamp.nos.social", "wss://eu.purplerelay.com",
                "wss://fabian.nostr1.com", "wss://feeds.nostr.band", "wss://fiatjaf.com", "wss://fiatjaf.nostr1.com",
                "wss://fido-news.z7.ai", "wss://fl.purplerelay.com", "wss://free.relayted.de", "wss://freelay.sovbit.host",
                "wss://frens.nostr1.com", "wss://frjosh.nostr1.com", "wss://gitcitadel.nostr1.com", "wss://greensoul.space",
                "wss://groups.0xchat.com", "wss://groups.fiatjaf.com", "wss://groups.yugoatobe.com",
                "wss://h.codingarena.top", "wss://haven.calva.dev", "wss://haven.ciori.net", "wss://haven.eternal.gdn",
                "wss://haven.on4r.net", "wss://haven.relayted.de", "wss://haven.tealeaf.dev", "wss://hax.reliefcloud.com",
                "wss://hbr.coracle.social", "wss://hist.nostr.land", "wss://hivetalk.nostr1.com",
                "wss://hotrightnow.nostr1.com", "wss://in.purplerelay.com", "wss://inbox.azzamo.net",
                "wss://inner.sebastix.social", "wss://ir.purplerelay.com", "wss://ithurtswhenip.ee", "wss://jellyfish.land",
                "wss://jingle.carlos-cdb.top", "wss://jingle.nostrver.se", "wss://kirpy.nostrnaut.love",
                "wss://knostr.neutrine.com", "wss://koru.bitcointxoko.com", "wss://lightningrelay.com",
                "wss://lunchbox.sandwich.farm", "wss://mandidraws.nostrnaut.love", "wss://me.purplerelay.com",
                "wss://mleku.nostr1.com", "wss://monitorlizard.nostr1.com", "wss://multiplexer.huszonegy.world",
                "wss://n.ok0.org", "wss://nip85.nostr.band", "wss://no.str.cr", "wss://nortis.nostr1.com", "wss://nos.lol",
                "wss://nos.xmark.cc", "wss://nosfabrica.nostr1.com", "wss://nostr-01.yakihonne.com",
                "wss://nostr-02.dorafactory.org", "wss://nostr-02.yakihonne.com", "wss://nostr-03.dorafactory.org",
                "wss://nostr-1.nbo.angani.co", "wss://nostr-dev.wellorder.net", "wss://nostr-dev.zbd.gg",
                "wss://nostr-pr01.redscrypt.org:47443", "wss://nostr-pr02.redscrypt.org", "wss://nostr-pr03.redscrypt.org",
                "wss://nostr-pub.wellorder.net", "wss://nostr-relay.amethyst.name", "wss://nostr-relay.psfoundation.info",
                "wss://nostr-relay.schnitzel.world", "wss://nostr-relay01.redscrypt.org:48443",
                "wss://nostr-rs-relay.dev.fedibtc.com", "wss://nostr-verified.wellorder.net", "wss://nostr.0x7e.xyz",
                "wss://nostr.1sat.org", "wss://nostr.256k1.dev", "wss://nostr.2b9t.xyz", "wss://nostr.2h2o.io",
                "wss://nostr.agentcampfire.com", "wss://nostr.app.runonflux.io", "wss://nostr.asdf.mx", "wss://nostr.at",
                "wss://nostr.azzamo.net", "wss://nostr.bilthon.dev", "wss://nostr.bitcoiner.social",
                "wss://nostr.bitcoinist.org", "wss://nostr.bitcoinvn.io", "wss://nostr.camalolo.com",
                "wss://nostr.caramboo.com", "wss://nostr.chaima.info", "wss://nostr.cizmar.net",
                "wss://nostr.cloud.vinney.xyz", "wss://nostr.coincards.com", "wss://nostr.cypherpunk.today",
                "wss://nostr.czas.plus", "wss://nostr.d11n.net", "wss://nostr.decentony.com", "wss://nostr.demery.net",
                "wss://nostr.dl3.dedyn.io", "wss://nostr.dlsouza.lol", "wss://nostr.dodge.me.uk", "wss://nostr.easydns.ca",
                "wss://nostr.einundzwanzig.space", "wss://nostr.extrabits.io", "wss://nostr.felixzieger.de",
                "wss://nostr.fort-btc.club", "wss://nostr.frostr.xyz", "wss://nostr.gleeze.com", "wss://nostr.hashbang.nl",
                "wss://nostr.hekster.org", "wss://nostr.hifish.org", "wss://nostr.holbrook.no", "wss://nostr.jcloud.es",
                "wss://nostr.jfischer.org", "wss://nostr.jonmartins.com", "wss://nostr.kloudcover.com",
                "wss://nostr.koning-degraaf.nl", "wss://nostr.kungfu-g.rip", "wss://nostr.liberty.fans",
                "wss://nostr.lopp.social", "wss://nostr.lorentz.is", "wss://nostr.massmux.com", "wss://nostr.mom",
                "wss://nostr.myshosholoza.co.za", "wss://nostr.nodeofsven.com", "wss://nostr.noderunners.network",
                "wss://nostr.noones.com", "wss://nostr.nordlysln.net:3241", "wss://nostr.notribe.net",
                "wss://nostr.on4r.net", "wss://nostr.oxtr.dev", "wss://nostr.pailakapo.com", "wss://nostr.pareto.space",
                "wss://nostr.polyserv.xyz", "wss://nostr.psychoet.nexus", "wss://nostr.rblb.it:7777",
                "wss://nostr.reelnetwork.eu", "wss://nostr.rikmeijer.nl", "wss://nostr.roundrockbitcoiners.com",
                "wss://nostr.rtvslawenia.com", "wss://nostr.sagaciousd.com", "wss://nostr.sathoarder.com",
                "wss://nostr.satstralia.com", "wss://nostr.sebastix.dev", "wss://nostr.sectiontwo.org",
                "wss://nostr.self-determined.de", "wss://nostr.snowbla.de", "wss://nostr.sovbit.host",
                "wss://nostr.sprovoost.nl", "wss://nostr.stakey.net", "wss://nostr.strits.dk",
                "wss://nostr.sudocarlos.com", "wss://nostr.tac.lol", "wss://nostr.tavux.tech", "wss://nostr.thurk.org",
                "wss://nostr.tools.global.id", "wss://nostr.vulpem.com", "wss://nostr.xmr.rocks", "wss://nostr.yael.at",
                "wss://nostr.zbd.gg", "wss://nostr01.counterclockwise.io", "wss://nostr21.com",
                "wss://nostream-production-643a.up.railway.app", "wss://nostrelay.circum.space",
                "wss://nostrelay.taylorperron.com", "wss://nostrua.com", "wss://nostrue.com", "wss://nr.rosano.ca",
                "wss://nr.yay.so", "wss://nsrelay.assilvestrar.club", "wss://offchain.pub", "wss://orangepiller.org",
                "wss://paid.no.str.cr", "wss://paid.nostrified.org", "wss://pareto.nostr1.com", "wss://pl.unostr.one",
                "wss://pnostr.self-determined.de", "wss://podsystems.nostr1.com", "wss://powrelay.xyz",
                "wss://primus.nostr1.com", "wss://prl.plus", "wss://problematic.network", "wss://profiles.nostr1.com",
                "wss://promenade.fiatjaf.com", "wss://purplerelay.com", "wss://pyramid.fiatjaf.com",
                "wss://relay-nwc.rizful.com", "wss://relay-rpi.edufeed.org", "wss://relay-testnet.k8s.layer3.news",
                "wss://relay.0xchat.com", "wss://relay.757btc.org", "wss://relay.agorist.space", "wss://relay.angor.io",
                "wss://relay.artx.market", "wss://relay.arx-ccn.com", "wss://relay.asthroughfire.com",
                "wss://relay.azzamo.net", "wss://relay.basspistol.org", "wss://relay.benthecarman.com",
                "wss://relay.beta.fogtype.com", "wss://relay.bitcoinpark.com", "wss://relay.bitcoinschool.nl",
                "wss://relay.bitcoinveneto.org", "wss://relay.bitdevs.tw", "wss://relay.brightbolt.net",
                "wss://relay.buildtall.com", "wss://relay.camelus.app", "wss://relay.caramboo.com",
                "wss://relay.cashumints.space", "wss://relay.copylaradio.com", "wss://relay.corpum.com",
                "wss://relay.cosmicbolt.net", "wss://relay.credenso.cafe", "wss://relay.d11n.net",
                "wss://relay.danieldaquino.me", "wss://relay.das.casa", "wss://relay.davidebtc.me",
                "wss://relay.degmods.com", "wss://relay.denver.space", "wss://relay.devvul.com",
                "wss://relay.diablocanyon1.com", "wss://relay.digitalezukunft.cyou", "wss://relay.drss.io",
                "wss://relay.electriclifestyle.com", "wss://relay.evanverma.com", "wss://relay.fr13nd5.com",
                "wss://relay.g1sms.fr", "wss://relay.gathr.gives", "wss://relay.groups.nip29.com",
                "wss://relay.guggero.org", "wss://relay.hasenpfeffr.com", "wss://relay.hodl.ar", "wss://relay.hunos.hu",
                "wss://relay.illuminodes.com", "wss://relay.keychat.io", "wss://relay.kookykeys.com",
                "wss://relay.kreweofkeys.net", "wss://relay.lifpay.me", "wss://relay.lightning.gdn",
                "wss://relay.lnfi.network", "wss://relay.lumina.rocks", "wss://relay.magiccity.live",
                "wss://relay.mess.ch", "wss://relay.mostard.org", "wss://relay.mostro.network",
                "wss://relay.nbswozlfpjuwc4y.boo", "wss://relay.needs.tr", "wss://relay.netstr.io",
                "wss://relay.noderunners.network", "wss://relay.nos.social", "wss://relay.nosotros.app",
                "wss://relay.nosto.re", "wss://relay.nostpy.lol", "wss://relay.nostr.band", "wss://relay.nostr.lighting",
                "wss://relay.nostr.net", "wss://relay.nostr.nu", "wss://relay.nostr.sc", "wss://relay.nostr.watch",
                "wss://relay.nostr.wf", "wss://relay.nostrarabia.com", "wss://relay.nostrdice.com",
                "wss://relay.nostrdvm.com", "wss://relay.nostrfreedom.net", "wss://relay.nostrhub.fr",
                "wss://relay.nostrified.org", "wss://relay.nostriot.com", "wss://relay.nostromo.social",
                "wss://relay.nostrplebs.com", "wss://relay.nostrr.de", "wss://relay.nostrtalk.org",
                "wss://relay.nostrverified.fyi", "wss://relay.nostrview.com", "wss://relay.noswhere.com",
                "wss://relay.notoshi.win", "wss://relay.nsec.app", "wss://relay.nuts.cash", "wss://relay.openbalance.app",
                "wss://relay.pituf.in", "wss://relay.pleb.to", "wss://relay.purplestr.com", "wss://relay.reya.su",
                "wss://relay.rkus.se", "wss://relay.s3x.social", "wss://relay.satlantis.io",
                "wss://relay.satoshidnc.com", "wss://relay.satsdays.com", "wss://relay.shawnyeager.com",
                "wss://relay.shop21.dk", "wss://relay.sigit.io", "wss://relay.stream.labs.h3.se",
                "wss://relay.tagayasu.xyz", "wss://relay.tapestry.ninja", "wss://relay.test.nquiz.io",
                "wss://relay.unsupervised.online", "wss://relay.usefusion.ai", "wss://relay.vanderwarker.family",
                "wss://relay.varke.eu", "wss://relay.vertexlab.io", "wss://relay.wavlake.com",
                "wss://relay.wellorder.net", "wss://relay.weloveit.info", "wss://relay.westernbtc.com",
                "wss://relay.wikifreedia.xyz", "wss://relay.yana.do", "wss://relay.ziomc.com", "wss://relay.zone667.com",
                "wss://relay01.lnfi.network", "wss://relay02.lnfi.network", "wss://relay03.lnfi.network",
                "wss://relay04.lnfi.network", "wss://relay1.nostrchat.io", "wss://relay1.plor.dev",
                "wss://relay2.angor.io", "wss://relay2.nostrchat.io", "wss://relaypag.es", "wss://rocky.nostr1.com",
                "wss://santo.iguanatech.net", "wss://satsage.xyz", "wss://seth.nostr1.com",
                "wss://skeme.vanderwarker.family", "wss://slick.mjex.me", "wss://social.olsentribe.fyi",
                "wss://strfry.bonsai.com", "wss://strfry.openhoofd.nl", "wss://strfry.shock.network",
                "wss://tamby.mjex.me", "wss://team-relay.pareto.space", "wss://tollbooth.stens.dev",
                "wss://uk.purplerelay.com", "wss://unostr.one", "wss://us.azzamo.net", "wss://user.kindpag.es",
                "wss://vidono.apps.slidestr.net", "wss://vitor.nostr1.com", "wss://wbc.nostr1.com", "wss://wons.calva.dev",
                "wss://wot.codingarena.top", "wss://wot.danieldaquino.me", "wss://wot.nostr.sats4.life",
                "wss://wot.relay.vanderwarker.family", "wss://wot.relayted.de", "wss://wot.sebastix.social",
                "wss://xmr.usenostr.org"
            ];

            // --- State ---
            let dht = {};
            const nodePositions = {};
            let sourceNodeUrl = null;
            let highlightCircle = null;
            let bootstrapUrl = null;

            // --- Pure Helper Functions (Browser Adapted) ---
            const sha256 = async (str) => {
                const buffer = new TextEncoder().encode(str);
                const hashBuffer = await crypto.subtle.digest('SHA-256', buffer);
                const hashArray = Array.from(new Uint8Array(hashBuffer));
                return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            };
            const getNodeId = sha256;
            const hexToBigInt = hex => BigInt(`0x${hex}`);
            const xorDistance = (id1, id2) => hexToBigInt(id1) ^ hexToBigInt(id2);
            const getBucketIndex = (ownId, otherId) => {
                const dist = xorDistance(ownId, otherId);
                if (dist === 0n) return -1;
                return ID_LENGTH_BITS - dist.toString(2).length;
            };

            const decodeNpub = (npub) => {
                try {
                    if (!npub.startsWith('npub1')) return null;
                    const { prefix, words } = bech32.decode(npub);
                    if (prefix !== 'npub') return null;
                    const data = new Uint8Array(bech32.fromWords(words));
                    return Array.from(data).map(b => b.toString(16).padStart(2, '0')).join('');
                } catch (e) {
                    console.error("Npub decoding failed:", e);
                    return null;
                }
            };

            // --- "State Transition" Functions ---
            const createNode = async (url) => ({
                url,
                id: await getNodeId(url),
                table: Array.from({ length: ID_LENGTH_BITS }, () => [])
            });

            const addNodeToTable = (table, nodeUrl, nodeId, ownId) => {
                const bucketIndex = getBucketIndex(ownId, nodeId);
                if (bucketIndex < 0 || table[bucketIndex].includes(nodeUrl)) return table;
                if (table[bucketIndex].length >= K) return table;
                const newTable = table.map(bucket => [...bucket]);
                newTable[bucketIndex] = [...newTable[bucketIndex], nodeUrl];
                return newTable;
            };

            const updateNodeTable = (dht, urlToUpdate, newTable) => ({
                ...dht,
                [urlToUpdate]: { ...dht[urlToUpdate], table: newTable }
            });

            const findKClosest = (dht, nodeUrls, targetId) =>
                [...new Set(nodeUrls)]
                    .sort((a, b) => {
                        const distA = xorDistance(dht[a].id, targetId);
                        const distB = xorDistance(dht[b].id, targetId);
                        return distA < distB ? -1 : distA > distB ? 1 : 0;
                    })
                    .slice(0, K);

            const logNetworkStats = (dht) => {
                console.log(`%c--- Network Stats ---`, 'font-weight: bold; font-size: 1.2em;');
                const nodeUrls = Object.keys(dht);
                const totalNodes = nodeUrls.length;
                let totalEntries = 0;
                let emptyNodes = 0;
                const tableSizes = [];
                const bucketCounts = [];

                nodeUrls.forEach(url => {
                    const node = dht[url];
                    const tableSize = node.table.flat().length;
                    const nonEmptyBuckets = node.table.filter(b => b.length > 0).length;

                    if (tableSize === 0) {
                        emptyNodes++;
                    }
                    totalEntries += tableSize;
                    tableSizes.push(tableSize);
                    bucketCounts.push(nonEmptyBuckets);
                });

                const averageEntries = totalEntries / totalNodes;
                const averageBuckets = bucketCounts.reduce((a, b) => a + b, 0) / totalNodes;

                console.log(`Total nodes in DHT: ${totalNodes}`);
                console.log(`Average routing table size: ${averageEntries.toFixed(2)}`);
                console.log(`Average non-empty buckets per node: ${averageBuckets.toFixed(2)}`);
                console.log(`Nodes with empty tables: ${emptyNodes}`);

                console.log(`%c--- Individual Node Tables ---`, 'font-weight: bold; font-size: 1.1em;');
                nodeUrls.sort().forEach(url => {
                    const node = dht[url];
                    const tableSize = node.table.flat().length;
                    const nonEmptyBuckets = node.table.filter(b => b.length > 0).length;
                    console.log(`${url.padEnd(40)} | Entries: ${String(tableSize).padStart(3)} | Buckets: ${String(nonEmptyBuckets).padStart(3)}`);
                });
            };

            // --- Simulation Core ---
            const runLookup = async (dht, queryingUrl, targetNodeUrl, targetId, bootstrapUrls, verbose = false) => {
                let currentDht = dht;
                const queryingId = currentDht[queryingUrl].id;
                const path = [];
                const discoveryPath = []; // Track how target was discovered
                const ownTableNodes = currentDht[queryingUrl].table.flat();
                const initialPeers = [...new Set([...ownTableNodes, ...bootstrapUrls])];
                let shortlist = findKClosest(currentDht, initialPeers, targetId).map(url => ({ url, queried: false, recommender: queryingUrl, round: 0 }));

                // Check if target is in initial peers
                if (targetNodeUrl && shortlist.some(n => n.url === targetNodeUrl)) {
                    discoveryPath.push([queryingUrl, targetNodeUrl]);
                }

                if (verbose) {
                    console.log(`%cStarting lookup from ${queryingUrl} for target ${targetId.slice(0, 10)}... (${targetNodeUrl})`, 'font-weight: bold; font-size: 1.2em;');
                    console.log(`Initial shortlist:`, shortlist.map(n => n.url));
                }

                let round = 0;
                while (true) {
                    round++;
                    if (verbose) console.log(`%c--- Round ${round} ---`, 'color: blue; font-weight: bold;');

                    const nodesToQuery = shortlist.filter(n => !n.queried).slice(0, ALPHA);
                    if (nodesToQuery.length === 0) {
                        if (verbose) console.log("No more unqueried nodes in shortlist. Terminating.");
                        break;
                    }

                    if (verbose) console.log(`Querying ${nodesToQuery.length} nodes concurrently...`);

                    for (const { url: nodeToQueryUrl, recommender: recommenderUrl } of nodesToQuery) {
                        path.push([recommenderUrl, nodeToQueryUrl]);
                        const shortlistEntry = shortlist.find(n => n.url === nodeToQueryUrl);
                        if (shortlistEntry) shortlistEntry.queried = true;

                        if (verbose) {
                            const dist = xorDistance(dht[nodeToQueryUrl].id, targetId);
                            const percentage = (dist * 10000n) / MAX_DISTANCE;
                            const displayPercent = (Number(percentage) / 100).toFixed(2);
                            console.log(`  -> Querying ${nodeToQueryUrl} (recommended by ${recommenderUrl}) (distance: ${displayPercent}%)`);
                        }

                        const oldTable = currentDht[nodeToQueryUrl].table;
                        const newTable = addNodeToTable(oldTable, queryingUrl, queryingId, currentDht[nodeToQueryUrl].id);
                        if (oldTable !== newTable) {
                            currentDht = updateNodeTable(currentDht, nodeToQueryUrl, newTable);
                        }

                        const knownToNode = currentDht[nodeToQueryUrl].table.flat();
                        const responseNodes = findKClosest(currentDht, knownToNode, targetId);

                        if (verbose) {
                            console.log(`    <- Response from ${nodeToQueryUrl} with ${responseNodes.length} nodes:`, responseNodes);
                        }

                        responseNodes.forEach(url => {
                            if (!shortlist.some(n => n.url === url)) {
                                shortlist.push({ url, queried: false, recommender: nodeToQueryUrl, round });
                                // Track if this response contains our target
                                if (targetNodeUrl && url === targetNodeUrl) {
                                    discoveryPath.push([nodeToQueryUrl, targetNodeUrl]);
                                }
                            }
                        });
                    }

                    const allShortlistUrls = shortlist.map(n => n.url);
                    const sortedUrls = findKClosest(currentDht, allShortlistUrls, targetId);
                    const oldShortlist = shortlist;
                    shortlist = sortedUrls.map(url => oldShortlist.find(n => n.url === url));

                    if (verbose) {
                        console.log("Updated shortlist (sorted and trimmed):", shortlist.map(n => ({...n})));
                    }

                    if (shortlist.every(n => n.queried)) {
                        if (verbose) console.log("All nodes in shortlist have been queried. Terminating.");
                        break;
                    }
                }

                let finalTable = currentDht[queryingUrl].table;
                shortlist.forEach(({ url }) => {
                    finalTable = addNodeToTable(finalTable, url, currentDht[url].id, queryingId);
                });
                currentDht = updateNodeTable(currentDht, queryingUrl, finalTable);

                // Build the discovery path showing how target was found
                let bestPath = [];
                if (targetNodeUrl && discoveryPath.length > 0) {
                    // Get all nodes that discovered the target (excluding the querying node itself)
                    const discoverers = [...new Set(discoveryPath.map(([from, to]) => from))].filter(url => url !== queryingUrl);
                    
                    if (discoverers.length > 0) {
                        // For each discoverer, we need to trace back how we got to it
                        discoverers.forEach(discoverer => {
                            // Find how we got to this discoverer
                            const discovererEntry = shortlist.find(n => n.url === discoverer);
                            if (discovererEntry && discovererEntry.recommender && discovererEntry.recommender !== queryingUrl) {
                                // Add path from querying node to the recommender, then to discoverer
                                bestPath.push([queryingUrl, discovererEntry.recommender]);
                                bestPath.push([discovererEntry.recommender, discoverer]);
                            } else {
                                // Direct path from querying node to discoverer
                                bestPath.push([queryingUrl, discoverer]);
                            }
                            // Add path from discoverer to target
                            bestPath.push([discoverer, targetNodeUrl]);
                        });
                    } else {
                        // If target was in initial shortlist, draw direct path
                        bestPath.push([queryingUrl, targetNodeUrl]);
                    }
                }

                if (verbose) {
                    console.log(`%c--- Lookup Complete ---`, 'font-weight: bold; font-size: 1.2em;');
                    console.log(`Final K-closest nodes found:`, shortlist.map(n => n.url));
                    if (bestPath.length > 0) {
                        const traversed = [bestPath[0][0]];
                        bestPath.forEach(([, to]) => traversed.push(to));
                        console.log(`%cDiscovery path to target:`, 'color: green; font-weight: bold;');
                        console.log(traversed.join(' -> '));
                        console.log(`%cNodes that discovered target:`, 'color: green; font-weight: bold;');
                        discoveryPath.forEach(([from, to]) => console.log(`  ${from} -> ${to}`));
                    }
                }

                return { dht: currentDht, result: shortlist.map(n => n.url), path, bestPath };
            };

            // --- SVG Drawing and Interaction ---
            const drawResultHighlights = (nodeUrls) => {
                document.querySelectorAll('.result-highlight').forEach(el => el.remove());
                nodeUrls.forEach(url => {
                    const pos = nodePositions[url];
                    if (pos) {
                        const circle = document.createElementNS(NS, 'circle');
                        circle.classList.add('result-highlight');
                        circle.setAttribute('r', 12);
                        circle.setAttribute('cx', pos.x);
                        circle.setAttribute('cy', pos.y);
                        svg.appendChild(circle);
                    }
                });
            };

            const drawNode = (node, x, y) => {
                const g = document.createElementNS(NS, 'g');
                g.classList.add('node-group');
                g.setAttribute('transform', `translate(${x}, ${y})`);
                g.addEventListener('click', () => handleNodeClick(node.url));

                const circle = document.createElementNS(NS, 'circle');
                circle.setAttribute('r', 5);
                circle.classList.add('node-circle');

                const nameText = document.createElementNS(NS, 'text');
                nameText.classList.add('node-label');
                nameText.setAttribute('y', 15);
                nameText.textContent = node.url.replace('wss://', '').replace(/\/$/, '');

                const hashText = document.createElementNS(NS, 'text');
                hashText.classList.add('node-label');
                hashText.setAttribute('y', 25);
                hashText.textContent = node.id.substring(0, 10) + '...';

                g.appendChild(circle);
                g.appendChild(nameText);
                g.appendChild(hashText);
                svg.appendChild(g);
            };

            const drawPath = (allPaths, bestPath) => {
                document.querySelectorAll('.path-line').forEach(el => el.remove());
                const pathGroup = document.createElementNS(NS, 'g');
                const bestPathSet = new Set(bestPath.map(([from, to]) => `${from}->${to}`));

                allPaths.forEach(([fromUrl, toUrl]) => {
                    const fromPos = nodePositions[fromUrl];
                    const toPos = nodePositions[toUrl];
                    if (fromPos && toPos) {
                        const line = document.createElementNS(NS, 'line');
                        line.setAttribute('x1', fromPos.x);
                        line.setAttribute('y1', fromPos.y);
                        line.setAttribute('x2', toPos.x);
                        line.setAttribute('y2', toPos.y);
                        line.classList.add('path-line');
                        if (bestPathSet.has(`${fromUrl}->${toUrl}`)) {
                            line.classList.add('best-path');
                        }
                        pathGroup.appendChild(line);
                    }
                });
                svg.insertBefore(pathGroup, svg.firstChild.nextSibling.nextSibling);
            };

            const handleNodeClick = async (nodeUrl) => {
                if (!sourceNodeUrl) {
                    sourceNodeUrl = nodeUrl;
                    if (highlightCircle) highlightCircle.remove();
                    highlightCircle = document.createElementNS(NS, 'circle');
                    highlightCircle.classList.add('highlight');
                    highlightCircle.setAttribute('r', 10);
                    const pos = nodePositions[nodeUrl];
                    highlightCircle.setAttribute('cx', pos.x);
                    highlightCircle.setAttribute('cy', pos.y);
                    svg.appendChild(highlightCircle);
                    lookupContainer.style.display = 'block';
                    npubInput.focus();
                } else {
                    lookupContainer.style.display = 'none';
                    const targetNodeUrl = nodeUrl;
                    if (sourceNodeUrl === targetNodeUrl) return;

                    const targetId = dht[targetNodeUrl].id;
                    const { path, bestPath } = await runLookup(dht, sourceNodeUrl, targetNodeUrl, targetId, [bootstrapUrl], true);
                    drawPath(path, bestPath || []);
                    drawResultHighlights([]); // Clear blue highlights

                    sourceNodeUrl = null;
                    if (highlightCircle) {
                        highlightCircle.style.opacity = '0';
                        setTimeout(() => {
                            if (highlightCircle) highlightCircle.remove();
                            highlightCircle = null;
                        }, 500);
                    }
                }
            };

            const handleNpubLookup = async () => {
                if (!sourceNodeUrl) return;

                const input = npubInput.value.trim();
                let targetId;

                if (input.startsWith('npub1')) {
                    targetId = decodeNpub(input);
                    if (!targetId) {
                        alert('Invalid npub format.');
                        return;
                    }
                } else if (/^[0-9a-f]{64}$/i.test(input)) {
                    targetId = input;
                } else {
                    alert('Please enter a valid npub or 64-char hex pubkey.');
                    return;
                }

                lookupContainer.style.display = 'none';
                npubInput.value = '';

                const { path, result } = await runLookup(dht, sourceNodeUrl, null, targetId, [bootstrapUrl], true);
                drawPath(path, []); // Draw lookup path, no "best path"
                drawResultHighlights(result); // Highlight k-closest nodes in blue

                sourceNodeUrl = null;
                if (highlightCircle) {
                    highlightCircle.style.opacity = '0';
                    setTimeout(() => {
                        if (highlightCircle) highlightCircle.remove();
                        highlightCircle = null;
                    }, 500);
                }
            };

            lookupButton.addEventListener('click', handleNpubLookup);
            npubInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    handleNpubLookup();
                }
            });

            // --- Main Execution ---
            console.log("Initializing DHT...");
            for (const url of relayUrls) {
                dht[url] = await createNode(url);
            }

            const shuffledRelays = [...relayUrls].sort(() => Math.random() - 0.5);
            bootstrapUrl = shuffledRelays[0];
            const otherUrls = shuffledRelays.filter(url => url !== bootstrapUrl);

            console.log(`Bootstrap node: ${bootstrapUrl}`);
            for (let i = 0; i < otherUrls.length; i++) {
                const url = otherUrls[i];
                loadingDiv.textContent = `Bootstrapping ${i + 1}/${otherUrls.length}`;
                const { dht: newDht } = await runLookup(dht, url, url, dht[url].id, [bootstrapUrl]);
                dht = newDht;
            }

            console.log("Stabilizing network...");
            const STABILIZATION_ROUNDS = 2;
            for (let i = 0; i < STABILIZATION_ROUNDS; i++) {
                loadingDiv.textContent = `Stabilizing round ${i + 1}/${STABILIZATION_ROUNDS}`;
                for (const url of relayUrls) {
                    const randomId = await sha256(Math.random().toString());
                    const { dht: newDht } = await runLookup(dht, url, null, randomId, [bootstrapUrl]);
                    dht = newDht;
                }
            }

            logNetworkStats(dht);

            console.log("DHT initialized. Drawing nodes.");
            loadingDiv.style.display = 'none';
            svg.style.visibility = 'visible';

            const { width, height } = svg.getBoundingClientRect();
            Object.values(dht).forEach(node => {
                const x = 50 + Math.random() * (width - 100);
                const y = 50 + Math.random() * (height - 100);
                nodePositions[node.url] = { x, y };
                drawNode(node, x, y);
            });
        })();
    </script>
</body>
</html>
